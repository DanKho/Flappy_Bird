# flappyBird_v1.py
# Creator - Danila Khomenko

# ===================  IMPORTS  ===================+
import tkinter as tk
import tkinter.ttk as ttk
import random
import time


# ==================  CLASS CODE  ==================+
class Bird:
    """
    Represents the Bird on the main screen
    """

    _PLAYER_IMAGE_FILE = "sprites/bird.png"
    _GRAVITY_Y_SPEED = 3
    _JUMP_Y_SPEED = -5

    def __init__(self, root, canvas, window_width, window_height):
        """
        :param root:
        :param canvas:
        :param window_width:
        :param window_height:
        """
        self._root = root
        self._canvas = canvas
        self._window_width = window_width
        self._window_height = window_height

        self._player_sprite = tk.PhotoImage(file=self._PLAYER_IMAGE_FILE)
        self.player = self._canvas.create_image(self._window_width / 2, self._window_height / 2,
                                                image=self._player_sprite, anchor="c", tag="player")

        self._y_speed = self._GRAVITY_Y_SPEED

    def get_y_speed(self):
        """
        Get y_speed of the player
        """
        return self._y_speed

    def get_player_coords(self):
        """
        Get x and y coordinates of the player
        """
        return self._canvas.coords(self.player)

    def player_fall(self):
        """
        Make the player fall downward
        """
        self._canvas.move(self.player, 0, self._y_speed)
        self._y_speed += 0.25

    def player_jump(self):
        """
        Make the player jump upward
        """
        self._y_speed = self._JUMP_Y_SPEED


class Pipe:
    """
    Represents the Pipes generated by the game
    """
    _PIPE_WIDTH = 85
    _PIPE_SEPARATION_Y = 140  # 160
    _MAX_X_SPEED = -2.6  # -2
    _SPAWN_X = 487
    _PIPE_SPAWN_INTERVAL = 2  # 2.5

    def __init__(self, root, canvas, window_width, window_height):
        """
        :param root:
        :param canvas:
        :param window_width:
        :param window_height:
        """
        self._root = root  # are these public or private?
        self._canvas = canvas
        self._window_width = window_width
        self._window_height = window_height

        self._pipe_bottom = None  # Ask whether this is good practice
        self._pipe_top = None
        self._x = self._SPAWN_X

        self._pipe_drawn = False

        self._x_speed = self._MAX_X_SPEED

    def generate_pipe(self):
        """
        Call the _draw_pipe function when appropriate (determines when to draw a new pipe)
        """
        _time_elapsed = round(time.time(), 1)
        if _time_elapsed % self._PIPE_SPAWN_INTERVAL == 0:
            if not self._pipe_drawn:
                self._draw_pipe()
                self._pipe_drawn = True
        else:
            self._pipe_drawn = False

    def _draw_pipe(self):
        """
        Create and draw a new pipe on the canvas
        """
        pipe1_len_from_top = random.randrange(self._window_height - 460, self._window_height - 90)
        pipe2_len_from_top = pipe1_len_from_top - self._PIPE_SEPARATION_Y
        self._pipe_bottom = self._canvas.create_rectangle(self._x, pipe1_len_from_top, self._x + self._PIPE_WIDTH,
                                                          self._window_height + 5, fill="green", tag="pipe")

        self._pipe_top = self._canvas.create_rectangle(self._x, 0, self._x + self._PIPE_WIDTH, pipe2_len_from_top,
                                                       fill="green", tag="pipe")

    def move_pipe(self):
        """
        Make the pipe move left
        """
        self._canvas.move("pipe", self._x_speed, 0)


class MainApplication:
    _NEW_GAME = False
    """
    A class containing that constructs the game window
    and handles the application logic
    """

    def __init__(self):
        self.root = tk.Tk()
        self.root.title("FlappyBird_v1")

        self.width = 485  # Are these private or public?
        self.height = 640
        self._background_color = "#03adfc"

        self.canvas = tk.Canvas(self.root, width=self.width, height=self.height, background=self._background_color)
        self.canvas.grid(row=0, column=0)

        self._player = Bird(self.root, self.canvas, self.width, self.height)
        self._player_score = 0
        self.canvas.bind("<KeyPress>", self._key_pressed)
        self.canvas.focus_set()

        self._score_counter_text = self.canvas.create_text(self.width / 2, 120, text="{}".format(self._player_score),
                                                           fill="white", font=("Arial", 50), justify="center",
                                                           tag="score_counter")
        self._best_score = 0

        self.canvas.itemconfigure(self._score_counter_text, state='hidden')

        self._pipe = Pipe(self.root, self.canvas, self.width, self.height)
        self._last_pipe = 0

        self.root.eval('tk::PlaceWindow . center')
        self.root.resizable(False, False)
        self.root.mainloop()

    def _key_pressed(self, event):
        """
        Do something when the user presses a key (keyboard event handler)
        """
        key = event.keysym
        if key == "space":
            if not self._NEW_GAME:
                self._NEW_GAME = True
                self.canvas.focus_set()
                self._player.player_jump()
                self.main()
            else:
                if self._player.get_player_coords()[1] > 35:
                    self._player.player_jump()

    def _overlap_detection(self):
        """
        Detect when a collision or overlap occurs within the game between the player and other specified objects
        """
        pipe_objects = self.canvas.find_withtag("pipe")
        player_coords = self._player.get_player_coords()
        player_x = player_coords[0]
        player_y = player_coords[1]
        overlapping_objects = self.canvas.find_overlapping(player_x, player_y - 70, player_x, player_y + 70)
        for pipe in pipe_objects:
            if pipe in overlapping_objects:
                if player_x - round(self.canvas.coords(pipe)[0]) < 1:
                    self._last_pipe = pipe
                    self._player_score += 1
                    self._update_score()
        # TODO: make the bird edges round to increase precision of collision detection
        overlapping_objects = self.canvas.find_overlapping(player_x - 20, player_y - 20, player_x + 24, player_y + 18)
        for pipe in pipe_objects:
            # Utilising player_x would be more efficient, but requesting for a new set of coordinates is a necessity
            if pipe in overlapping_objects or self._player.get_player_coords()[1] > self.height - 28:
                return True
        else:
            return False

    def _update_score(self):
        """
        This function updates the main game score when the player scores a point
        """
        self.canvas.delete("score_counter")
        self._score_counter_text = self.canvas.create_text(self.width / 2, 120, text="{}".format(self._player_score),
                                                           fill="white", font=("Arial", 50), justify="center",
                                                           tag="score_counter")

    def _initialise_layout(self):
        """
        This function initialises the main game layout before each game starts
        """
        self.canvas.itemconfigure(self._score_counter_text, state='normal')
        self._player = Bird(self.root, self.canvas, self.width, self.height)

    def _game_begin(self):
        """
        This function carries out the game process
        """
        self.canvas.tag_raise(self._score_counter_text)
        collision = self._overlap_detection()
        self._pipe.generate_pipe()
        self._player.player_fall()
        self._pipe.move_pipe()
        if not collision:
            self.root.after(15, self._game_begin)
        else:
            self._game_over()

    def _game_over(self):
        """
        Generate the "game over" menu
        """
        self.canvas.delete("score_counter")
        if self._player_score > self._best_score:
            self._best_score = self._player_score
        scores_window = self.canvas.create_rectangle(self.width / 2 - 50, self.height / 2 - 135, self.width / 2 + 50,
                                                     self.height / 2 + 10, fill="yellow", tag="game_over_t")
        score_text = self.canvas.create_text(self.width / 2, self.height / 2 - 110, text="Score",
                                             fill="black", font=("Arial", 20), justify="center", tag="game_over_t")
        score_text_num = self.canvas.create_text(self.width / 2, self.height / 2 - 80, text=f"{self._player_score}",
                                                 fill="red", font=("Arial", 20), justify="center", tag="game_over_t")
        best_score_text = self.canvas.create_text(self.width / 2, self.height / 2 - 45, text="Best",
                                                  fill="black", font=("Arial", 20), justify="center", tag="game_over_t")
        best_score_text_num = self.canvas.create_text(self.width / 2, self.height / 2 - 15,
                                                      text=f"{self._best_score}",fill="red", font=("Arial", 20),
                                                      justify="center", tag="game_over_t")
        button_continue = tk.Button(self.canvas, text="Restart", anchor='c', font=("ROBOTO", 12, "bold"),
                                    command=self._restart_game)
        button_continue.configure(width=20, background="orange")
        button_window = self.canvas.create_window(self.width/2, self.height/2+50, window=button_continue,
                                                  tag="game_over_t")

    def _restart_game(self):
        """
        This function clears the main canvas window and restarts the game
        """
        self.canvas.delete("all")
        self._player_score = 0
        self._NEW_GAME = False
        self._initialise_layout()

    def main(self):
        """
        Main flow of the program
        """
        self._game_begin()


MainApplication()
